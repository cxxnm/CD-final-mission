#!/usr/bin/env python
# -*- coding: utf-8 -*-

################################################################################
# Copyright 2018 ROBOTIS CO., LTD.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################

# Author: Leon Jung, Gilbert, Ashe Kim
 
import os
import time
import rospy
import numpy as np

from std_msgs.msg import Float64
from geometry_msgs.msg import Twist
from gazebo_msgs.srv import SpawnModel, DeleteModel
from std_srvs.srv import Empty
from nav_msgs.msg import Odometry

class ControlLane():
    def __init__(self):
        self.sub_lane = rospy.Subscriber('/control/lane', Float64, self.cbFollowLane, queue_size=1)
        self.sub_max_vel = rospy.Subscriber('/control/max_vel', Float64, self.cbGetMaxVel, queue_size=1)
        self.sub_odom = rospy.Subscriber('odom', Odometry, self.getOdom, queue_size=1)
        self.pub_cmd_vel = rospy.Publisher('/control/cmd_vel', Twist, queue_size=1)

        self.lastError = 0
        self.MAX_VEL = 0.1
        self.rate = rospy.Rate(5)
        self.traffic_state = 1
        self.is_moving_complete = False
        self.initial_pose = None
        self.current_time = time.time()

        rospy.on_shutdown(self.fnShutDown)
        self.loadMissionModel()
        self.setTraffic()
        self.controlTrafficLights()

    def getOdom(self, msg):
        pose_x = msg.pose.pose.position.x
        pose_y = msg.pose.pose.position.y

        # down_bar
        if abs(pose_x + 1.4) < 0.15 and abs(pose_y - 1.25) < 0.05 and self.traffic_state == 5:
            self.traffic_state = 6

        # up_bar
        elif abs(pose_x + 1.3) < 0.15 and (pose_y - 1.25) < 0.05 and self.traffic_state == 7:
            self.traffic_state = 8
            self.current_time = time.time()

    def loadMissionModel(self):
        model_dir_path = os.path.dirname(os.path.realpath(__file__))
        model_dir_path = model_dir_path.replace(
            '/turtlebot3_autorace_2020/turtlebot3_autorace_driving/nodes',
            '/turtlebot3_simulations/turtlebot3_gazebo/models/turtlebot3_autorace_2020')

        turtlebot_dir_path = os.path.dirname(os.path.realpath(__file__))
        turtlebot_dir_path = turtlebot_dir_path.replace(
            '/turtlebot3_autorace_2020/turtlebot3_autorace_driving/nodes',
            '/turtlebot3_simulations/turtlebot3_gazebo/models/turtlebot3_burger/model.sdf')

        red_light_path = model_dir_path + '/traffic_light_red/model.sdf'
        red_light_model = open(red_light_path, 'r')
        self.red_light_model = red_light_model.read()

        yellow_light_path = model_dir_path + '/traffic_light_yellow/model.sdf'
        yellow_light_model = open(yellow_light_path, 'r')
        self.yellow_light_model = yellow_light_model.read()

        green_light_path = model_dir_path + '/traffic_light_green/model.sdf'
        green_light_model = open(green_light_path, 'r')
        self.green_light_model = green_light_model.read()

        traffic_circle_path = model_dir_path + '/traffic_circle/model.sdf'
        traffic_circle_model = open(traffic_circle_path, 'r')
        self.traffic_circle_model = traffic_circle_model.read()

        parking_model = open(turtlebot_dir_path, 'r')
        self.parking_model = parking_model.read().replace('<static>0', '<static>1')

    def setTraffic(self):
        rospy.wait_for_service('gazebo/spawn_sdf_model')
        spawn_model_prox = rospy.ServiceProxy('gazebo/spawn_sdf_model', SpawnModel)

        spawn_model_prox(
            'traffic_circle',
            self.traffic_circle_model,
            "robotos_name_space",
            self.initial_pose,
            "world")

        parking_pose = Pose()
        parking_stop = np.random.rand()
        parking_pose.position.x = 0.73 if parking_stop < 0.5 else 0.23
        parking_pose.position.y = 0.8
        parking_pose.position.z = 0.03
        parking_pose.orientation.x = 0
        parking_pose.orientation.y = 0
        parking_pose.orientation.z = -1
        parking_pose.orientation.w = -1

    def controlTrafficLights(self):
        while not rospy.is_shutdown():
            if self.traffic_state == 1:  # turn on red light
                rospy.wait_for_service('gazebo/spawn_sdf_model')
                spawn_model_prox = rospy.ServiceProxy('gazebo/spawn_sdf_model', SpawnModel)
                spawn_model_prox(
                    'traffic_light_red',
                    self.red_light_model,
                    "robotos_name_space",
                    self.initial_pose,
                    "world")

                self.traffic_state = 2
                self.current_time = time.time()

            elif self.traffic_state == 2:
                if abs(self.current_time - time.time()) > 2:  # turn on yellow light after 3s.
                    rospy.wait_for_service('gazebo/spawn_sdf_model')
                    spawn_model_prox = rospy.ServiceProxy('gazebo/spawn_sdf_model', SpawnModel)
                    spawn_model_prox(
                        'traffic_light_yellow',
                        self.yellow_light_model,
                        "robotos_name_space",
                        self.initial_pose,
                        "world")

                    del_model_prox = rospy.ServiceProxy('gazebo/delete_model', DeleteModel)
                    del_model_prox('traffic_light_red')
                    self.traffic_state = 3
                    self.current_time = time.time()

            elif self.traffic_state == 3:
                if abs(self.current_time - time.time()) > 5:  # turn on green light after 5s.
                    rospy.wait_for_service('gazebo/spawn_sdf_model')
                    spawn_model_prox = rospy.ServiceProxy('gazebo/spawn_sdf_model', SpawnModel)
                    spawn_model_prox('traffic_light_green', self.green_light_model, "robotos_name_space",
                                     self.initial_pose, "world")
                    del_model_prox = rospy.ServiceProxy('gazebo/delete_model', DeleteModel)
                    del_model_prox('traffic_light_yellow')
                    self.traffic_state = 4

            elif self.traffic_state == 4:
                if abs(self.current_time - time.time()) > 5:  # intersections
                    rospy.wait_for_service('gazebo/spawn_sdf_model')
                    del_model_prox = rospy.ServiceProxy('gazebo/delete_model', DeleteModel)
                    intersection_direction = np.random.rand()

                    self.traffic_state = 5

            elif self.traffic_state == 6:  # bar down.
                rospy.wait_for_service('gazebo/spawn_sdf_model')
                spawn_model_prox = rospy.ServiceProxy('gazebo/spawn_sdf_model', SpawnModel)
                spawn_model_prox('up_bar', self.up_bar_model, "robotos_name_space",
                                 self.initial_pose, "world")
                del_model_prox = rospy.ServiceProxy('gazebo/delete_model', DeleteModel)
                self.traffic_state = 7

            elif self.traffic_state == 8:  # bar up
                if abs(self.current_time - time.time()) > 10:
                    rospy.wait_for_service('gazebo/spawn_sdf_model')
                    spawn_model_prox = rospy.ServiceProxy('gazebo/spawn_sdf_model', SpawnModel)
                    del_model_prox = rospy.ServiceProxy('gazebo/delete_model', DeleteModel)
                    del_model_prox('up_bar')
                    rospy.signal_shutdown('shutdown')
            self.rate.sleep()

    def cbGetMaxVel(self, max_vel_msg):
        self.MAX_VEL = max_vel_msg.data

    def cbFollowLane(self, desired_center):
        center = desired_center.data

        error = center - 500

        Kp = 0.005
        Kd = 0.01

        angular_z = Kp * error + Kd * (error - self.lastError)
        self.lastError = error

        twist = Twist()
        try:
            twist.linear.x = min(self.MAX_VEL * ((1 - abs(error) / 500) ** 2.2), 0.02)
        except:
            twist.linear.x = 0.02
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = -max(angular_z, -0.1) if angular_z < 0 else -min(angular_z, 0.1)
        self.pub_cmd_vel.publish(twist)

    def fnShutDown(self):
        rospy.loginfo("Shutting down. cmd_vel will be 0")

        twist = Twist()
        twist.linear.x = 0
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = 0
        self.pub_cmd_vel.publish(twist)

    def main(self):
        rospy.spin()

if __name__ == '__main__':
    rospy.init_node('control_lane')
    node = ControlLane()
    node.main()
