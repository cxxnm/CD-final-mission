import rospy
import roslaunch
import os
from enum import Enum
from std_msgs.msg import UInt8

class CoreNodeController():
    def __init__(self):
        self.ros_package_path = os.path.dirname(os.path.realpath(__file__))
        self.ros_package_path = self.ros_package_path.replace('turtlebot3_autorace_core/nodes', '')

        # Subscribe to topics
        self.sub_mode_control = rospy.Subscriber('/core/decided_mode', UInt8, self.cbReceiveMode, queue_size=1)
        self.sub_construction_stamped = rospy.Subscriber('/detect/construction_stamped', UInt8, self.cbConstructionStamped, queue_size=1)
        self.sub_intersection_stamped = rospy.Subscriber('/detect/intersection_stamped', UInt8, self.cbIntersectionStamped, queue_size=1)
        self.sub_parking_stamped = rospy.Subscriber('/detect/parking_stamped', UInt8, self.cbParkingStamped, queue_size=1)
        self.sub_left_stamped = rospy.Subscriber('/detect/left_stamped', UInt8, self.cbLeftStamped, queue_size=1)
        self.sub_stop_stamped = rospy.Subscriber('/detect/stop_stamped', UInt8, self.cbStopStamped, queue_size=1)

        # Publish to topics
        self.pub_construction_order = rospy.Publisher('/detect/construction_order', UInt8, queue_size=1)
        self.pub_intersection_order = rospy.Publisher('/detect/intersection_order', UInt8, queue_size=1)
        self.pub_parking_order = rospy.Publisher('/detect/parking_order', UInt8, queue_size=1)
        self.pub_left_order = rospy.Publisher('/detect/left_order', UInt8, queue_size=1)
        self.pub_stop_order = rospy.Publisher('/detect/stop_order', UInt8, queue_size=1)
        self.pub_mode_return = rospy.Publisher('/core/returned_mode', UInt8, queue_size=1)

        # Define modes and steps
        self.CurrentMode = Enum('CurrentMode', ['idle', 'start', 'construction', 'intersection', 'lane_following', 'parking', 'stopping', 'left'])
        self.current_mode = self.CurrentMode.idle.value

        self.Step = Enum('Step', ['find_obstacle', 'avoid_obstacle', 'circling', 'parking', 'left', 'stop', 'exit'])
        self.current_step_construction = self.Step.find_obstacle.value
        self.current_step_intersection = self.Step.circling.value
        self.current_step_parking = self.Step.parking.value
        self.current_step_left = self.Step.left.value
        self.current_step_stopping = self.Step.stop.value

        self.Launcher = Enum('Launcher', [
            'launch_camera_ex_calib',
            'launch_detect_construction',
            'launch_detect_construction_sign',
            'launch_detect_intersection',
            'launch_detect_intersection_sign',
            'launch_detect_parking',
            'launch_detect_parking_sign',
            'launch_detect_left',
            'launch_detect_left_sign',
            'launch_detect_stop',
            'launch_detect_stop_sign',
            'launch_detect_lane',
            'launch_control_lane',
            'launch_control_moving'
        ])

        self.launch_files = {
            'launch_camera_ex_calib': 'turtlebot3_autorace_camera/launch/extrinsic_camera_calibration.launch',
            'launch_detect_construction': 'turtlebot3_autorace_detect/launch/detect_construction.launch',
            'launch_detect_construction_sign': 'turtlebot3_autorace_detect/launch/detect_construction_sign.launch',
            'launch_detect_intersection': 'turtlebot3_autorace_detect/launch/detect_intersection.launch',
            'launch_detect_intersection_sign': 'turtlebot3_autorace_detect/launch/detect_intersection_sign.launch',
            'launch_detect_parking': 'turtlebot3_autorace_detect/launch/detect_parking.launch',
            'launch_detect_parking_sign': 'turtlebot3_autorace_detect/launch/detect_parking_sign.launch',
            'launch_detect_left': 'turtlebot3_autorace_detect/launch/detect_left.launch',
            'launch_detect_left_sign': 'turtlebot3_autorace_detect/launch/detect_left_sign.launch',
            'launch_detect_stop': 'turtlebot3_autorace_detect/launch/detect_stop.launch',
            'launch_detect_stop_sign': 'turtlebot3_autorace_detect/launch/detect_stop_sign.launch',
            'launch_detect_lane': 'turtlebot3_autorace_detect/launch/detect_lane.launch',
            'launch_control_lane': 'turtlebot3_autorace_driving/launch/turtlebot3_autorace_control_lane.launch',
            'launch_control_moving': 'turtlebot3_autorace_driving/launch/turtlebot3_autorace_control_moving.launch'
        }

        self.uuid = roslaunch.rlutil.get_or_generate_uuid(None, False)
        roslaunch.configure_logging(self.uuid)
        self.processes = {}
        self.is_triggered = False
        self.is_started = True

        loop_rate = rospy.Rate(10) # 10hz
        while not rospy.is_shutdown():
            if self.is_started:
                self.current_mode = self.CurrentMode.start.value
                self.fnControlNode()
                self.is_started = False

            if self.is_triggered:
                self.fnControlNode()
                self.is_triggered = False
            
            loop_rate.sleep()

    def cbReceiveMode(self, mode_msg):
        rospy.loginfo(f"Received mode: {mode_msg.data}")
        self.current_mode = mode_msg.data
        self.is_triggered = True

    def cbConstructionStamped(self, construction_msg):
        rospy.loginfo(f"Construction step changed to: {construction_msg.data}")
        self.current_step_construction = construction_msg.data
        self.checkExitCondition(construction_msg.data, self.pub_construction_order)

    def cbIntersectionStamped(self, intersection_msg):
        rospy.loginfo(f"Intersection step changed to: {intersection_msg.data}")
        self.current_step_intersection = intersection_msg.data
        self.checkExitCondition(intersection_msg.data, self.pub_intersection_order)
    
    def cbParkingStamped(self, parking_msg):
        rospy.loginfo(f"Parking step changed to: {parking_msg.data}")
        self.current_step_parking = parking_msg.data
        self.checkExitCondition(parking_msg.data, self.pub_parking_order)
    
    def cbLeftStamped(self, left_msg):
        rospy.loginfo(f"Left step changed to: {left_msg.data}")
        self.current_step_left = left_msg.data
        self.checkExitCondition(left_msg.data, self.pub_left_order)
    
    def cbStopStamped(self, stopping_msg):
        rospy.loginfo(f"Stopping step changed to: {stopping_msg.data}")
        self.current_step_stopping = stopping_msg.data
        self.checkExitCondition(stopping_msg.data, self.pub_stop_order)

    def checkExitCondition(self, step, pub):
        if step == self.Step.exit.value:
            self.current_mode = self.CurrentMode.lane_following.value
            msg_mode_return = UInt8()
            msg_mode_return.data = self.current_mode
            self.pub_mode_return.publish(msg_mode_return)
            self.is_triggered = True
        else:
            self.is_triggered = True
            pub.publish(step)

    def fnControlNode(self):
        rospy.loginfo(f"Current mode: {self.CurrentMode(self.current_mode).name}")

        if self.current_mode == self.CurrentMode.start.value:
            self.start_mode()
        elif self.current_mode == self.CurrentMode.lane_following.value:
            self.lane_following_mode()
        elif self.current_mode == self.CurrentMode.intersection.value:
            self.intersection_mode()
        elif self.current_mode == self.CurrentMode.parking.value:
            self.parking_mode()
        elif self.current_mode == self.CurrentMode.left.value:
            self.left_mode()
        elif self.current_mode == self.CurrentMode.stopping.value:
            self.stopping_mode()
        elif self.current_mode == self.CurrentMode.construction.value:
            self.construction_mode()

    def start_mode(self):
        rospy.loginfo("START MODE")
        self.launch_all_nodes()
        self.current_mode = self.CurrentMode.lane_following.value

    def lane_following_mode(self):
        rospy.loginfo("LANE FOLLOWING MODE")
        self.fnLaunch('launch_detect_lane', True)
        self.fnLaunch('launch_control_lane', True)
        
    def intersection_mode(self):
        rospy.loginfo("INTERSECTION MODE")
        self.stop_lane_detection()
        msg_pub_intersection_order = UInt8()
        msg_pub_intersection_order.data = self.current_step_intersection
        self.pub_intersection_order.publish(msg_pub_intersection_order)

    def parking_mode(self):
        rospy.loginfo("PARKING MODE")
        msg_pub_parking_order = UInt8()
        msg_pub_parking_order.data = self.current_step_parking
        self.pub_parking_order.publish(msg_pub_parking_order)
    
    def left_mode(self):
        rospy.loginfo("LEFT MODE")
        msg_pub_left_order = UInt8()
        msg_pub_left_order.data = self.current_step_left
        self.pub_left_order.publish(msg_pub_left_order)
    
    def stopping_mode(self):
        rospy.loginfo("STOPPING MODE")
        msg_pub_stopping_order = UInt8()
        msg_pub_stopping_order.data = self.current_step_stopping
        self.pub_stop_order.publish(msg_pub_stopping_order)

    def construction_mode(self):
        rospy.loginfo("CONSTRUCTION MODE")
        msg_pub_construction_order = UInt8()
        msg_pub_construction_order.data = self.current_step_construction
        self.pub_construction_order.publish(msg_pub_construction_order)

    def stop_lane_detection(self):
        rospy.loginfo("STOP LANE DETECTION")
        self.fnLaunch('launch_detect_lane', False)
        self.fnLaunch('launch_control_lane', False)

    def launch_all_nodes(self):
        self.fnLaunch(self.Launcher.launch_camera_ex_calib.name, True)
        self.fnLaunch(self.Launcher.launch_detect_lane.name, True)
        self.fnLaunch(self.Launcher.launch_detect_intersection_sign.name, True)
        self.fnLaunch(self.Launcher.launch_detect_intersection.name, True)
        self.fnLaunch(self.Launcher.launch_detect_construction_sign.name, True)
        self.fnLaunch(self.Launcher.launch_detect_construction.name, True)
        self.fnLaunch(self.Launcher.launch_detect_parking_sign.name, True)
        self.fnLaunch(self.Launcher.launch_detect_parking.name, True)
        self.fnLaunch(self.Launcher.launch_detect_left_sign.name, True)
        self.fnLaunch(self.Launcher.launch_detect_left.name, True)
        self.fnLaunch(self.Launcher.launch_detect_stop_sign.name, True)
        self.fnLaunch(self.Launcher.launch_detect_stop.name, True)
        self.fnLaunch(self.Launcher.launch_control_lane.name, True)
        self.fnLaunch(self.Launcher.launch_control_moving.name, True)

    def fnLaunch(self, node_name, is_start):
        launch_file = self.launch_files[node_name]

        if is_start:
            if node_name in self.processes and self.processes[node_name] is not None:
                rospy.loginfo(f"{node_name} is already launched.")
            else:
                rospy.loginfo(f"Starting {node_name}")
                parent = roslaunch.parent.ROSLaunchParent(self.uuid, [self.ros_package_path + launch_file])
                self.processes[node_name] = parent
                parent.start()
        else:
            if node_name in self.processes and self.processes[node_name] is not None:
                rospy.loginfo(f"Stopping {node_name}")
                self.processes[node_name].shutdown()
                self.processes[node_name] = None

    def main(self):
        rospy.spin()

if __name__ == '__main__':
    rospy.init_node('core_node_controller')
    node = CoreNodeController()
    node.main()
