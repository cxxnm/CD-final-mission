import rospy, roslaunch
import os
from enum import Enum
from std_msgs.msg import UInt8, Float64

class CoreNodeController():
    def __init__(self):
        self.ros_package_path = os.path.dirname(os.path.realpath(__file__))
        self.ros_package_path = self.ros_package_path.replace('turtlebot3_autorace_core/nodes', '')

        # Subscribe to topics
        self.sub_mode_control = rospy.Subscriber('/core/decided_mode', UInt8, self.cbReceiveMode, queue_size=1)
        self.sub_construction_stamped = rospy.Subscriber('/detect/construction_stamped', UInt8, self.cbConstructionStamped, queue_size=1)
        self.sub_intersection_stamped = rospy.Subscriber('/detect/intersection_stamped', UInt8, self.cbIntersectionStamped, queue_size=1)
        self.sub_parking_stamped = rospy.Subscriber('/detect/parking_stamped', UInt8, self.cbParkingStamped, queue_size=1)

        # Publish to topics
        self.pub_construction_order = rospy.Publisher('/detect/construction_order', UInt8, queue_size=1)
        self.pub_intersection_order = rospy.Publisher('/detect/intersection_order', UInt8, queue_size=1)
        self.pub_parking_order = rospy.Publisher('/detect/parking_order', UInt8, queue_size=1)   
        self.pub_mode_return = rospy.Publisher('/core/returned_mode', UInt8, queue_size=1)

        # Define modes and steps
        self.CurrentMode = Enum('CurrentMode', ['idle', 'start', 'construction', 'intersection', 'lane_following', 'parking'])
        self.current_mode = self.CurrentMode.idle.value

        self.Step = Enum('Step', ['find_obstacle', 'avoid_obstacle', 'circling', 'parking', 'exit'])
        self.current_step_construction = self.Step.find_obstacle.value
        self.current_step_intersection = self.Step.circling.value
        self.current_step_parking = self.Step.parking.value

        self.Launcher = Enum('Launcher', [
            'launch_camera_ex_calib',
            'launch_detect_construction',
            'launch_detect_construction_sign',
            'launch_detect_intersection',
            'launch_detect_intersection_sign', 
            'launch_detect_parking',
            'launch_detect_parking_sign',
            'launch_detect_lane',
            'launch_control_lane',
            'launch_control_moving'
        ])

        self.uuid = roslaunch.rlutil.get_or_generate_uuid(None, False)
        self.processes = {}
        self.is_triggered = False
        self.is_started = True

        loop_rate = rospy.Rate(10) # 10hz
        while not rospy.is_shutdown():
            if self.is_started:
                self.current_mode = self.CurrentMode.start.value
                self.fnControlNode()
                self.is_started = False

            if self.is_triggered:
                self.fnControlNode()
                self.is_triggered = False
            
            loop_rate.sleep()

    def cbReceiveMode(self, mode_msg):
        rospy.loginfo(f"Received mode: {mode_msg.data}")
        self.current_mode = mode_msg.data
        self.is_triggered = True

    def cbConstructionStamped(self, construction_msg):
        rospy.loginfo(f"Construction step changed to: {construction_msg.data}")
        self.current_step_construction = construction_msg.data
        self.checkExitCondition(construction_msg.data, self.pub_construction_order)

    def cbIntersectionStamped(self, intersection_msg):
        rospy.loginfo(f"Intersection step changed to: {intersection_msg.data}")
        self.current_step_intersection = intersection_msg.data
        self.checkExitCondition(intersection_msg.data, self.pub_intersection_order)
    
    def cbParkingStamped(self, parking_msg):
        rospy.loginfo(f"Parking step changed to: {parking_msg.data}")
        self.current_step_parking = parking_msg.data
        self.checkExitCondition(parking_msg.data, self.pub_parking_order)

    def checkExitCondition(self, step, pub):
        if step == self.Step.exit.value:
            self.current_mode = self.CurrentMode.lane_following.value
            msg_mode_return = UInt8()
            msg_mode_return.data = self.current_mode
            self.pub_mode_return.publish(msg_mode_return)
            self.is_triggered = True
        else:
            self.is_triggered = True
            pub.publish(step)

    def fnControlNode(self):
        rospy.loginfo(f"Current mode: {self.CurrentMode(self.current_mode).name}")

        if self.current_mode == self.CurrentMode.start.value:
            self.start_mode()
        elif self.current_mode == self.CurrentMode.lane_following.value:
            self.lane_following_mode()
        elif self.current_mode == self.CurrentMode.intersection.value:
            self.intersection_mode()
        elif self.current_mode == self.CurrentMode.parking.value:
            self.parking_mode()
        elif self.current_mode == self.CurrentMode.construction.value:
            self.construction_mode()

    def start_mode(self):
        rospy.loginfo("START MODE")
        self.launch_all_nodes()
        self.current_mode = self.CurrentMode.lane_following.value

    def lane_following_mode(self):
        rospy.loginfo("LANE FOLLOWING MODE")
        self.launch_all_nodes_except(['launch_detect_intersection', 'launch_detect_construction', 'launch_detect_parking'])
        
    def intersection_mode(self):
        rospy.loginfo("INTERSECTION MODE")
        msg_pub_intersection_order = UInt8()
        msg_pub_intersection_order.data = self.current_step_intersection
        self.pub_intersection_order.publish(msg_pub_intersection_order)

    def parking_mode(self):
        rospy.loginfo("PARKING MODE")
        msg_pub_parking_order = UInt8()
        msg_pub_parking_order.data = self.current_step_parking
        self.pub_parking_order.publish(msg_pub_parking_order)

    def construction_mode(self):
        rospy.loginfo("CONSTRUCTION MODE")
        msg_pub_construction_order = UInt8()
        msg_pub_construction_order.data = self.current_step_construction
        self.pub_construction_order.publish(msg_pub_construction_order)

    def launch_all_nodes(self):
        self.fnLaunch(self.Launcher.launch_camera_ex_calib.value, True)
        self.fnLaunch(self.Launcher.launch_detect_lane.value, True)
        self.fnLaunch(self.Launcher.launch_detect_intersection_sign.value, True)
        self.fnLaunch(self.Launcher.launch_detect_intersection.value, True)
        self.fnLaunch(self.Launcher.launch_detect_construction_sign.value, True)
        self.fnLaunch(self.Launcher.launch_detect_construction.value, True)
        self.fnLaunch(self.Launcher.launch_detect_parking_sign.value, True)
        self.fnLaunch(self.Launcher.launch_detect_parking.value, True)
        self.fnLaunch(self.Launcher.launch_control_lane.value, True)
        self.fnLaunch(self.Launcher.launch_control_moving.value, False)

    def launch_all_nodes_except(self, exclude_list):
        for launcher in self.Launcher:
            if launcher.name not in exclude_list:
                self.fnLaunch(launcher.value, True)

    def fnLaunch(self, launch_num, is_start):
        if launch_num not in self.processes:
            self.processes[launch_num] = roslaunch.scriptapi.ROSLaunch()

        launch = self.processes[launch_num]
        node_name = self.Launcher(launch_num).name

        if is_start:
            if launch:
                rospy.loginfo(f"{node_name} is already launched.")
            else:
                rospy.loginfo(f"Starting {node_name}")
                launch = roslaunch.scriptapi.ROSLaunch()
                launch = roslaunch.parent.ROSLaunchParent(self.uuid, [self.ros_package_path + f"turtlebot3_autorace_{node_name.split('_')[1]}/launch/{node_name}.launch"])
                self.processes[launch_num] = launch
                launch.start()
        else:
            if launch:
                rospy.loginfo(f"Stopping {node_name}")
                launch.shutdown()
                self.processes[launch_num] = None

    def main(self):
        rospy.spin()

if __name__ == '__main__':
    rospy.init_node('core_node_controller')
    node = CoreNodeController()
    node.main()
